\documentclass[12]{amsart}

\usepackage{amssymb,amsmath}

%\usepackage{refcheck}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{fullpage} 
\usepackage{setspace}
\usepackage{color}
%\usepackage{ dsfont }
\usepackage{float}
\usepackage{physics}

%new math symbols taking no arguments
\newcommand\0{\mathbf{0}}
\newcommand\CC{\mathbb{C}}
\newcommand\FF{\mathbb{F}}
\newcommand\NN{\mathbb{N}}
\newcommand\QQ{\mathbb{Q}}
\newcommand\RR{\mathbb{R}}
\newcommand\ZZ{\mathbb{Z}}
\newcommand\bb{\mathbf{b}}
\newcommand\kk{\Bbbk}
\newcommand\mm{\mathfrak{m}}
\newcommand\pp{\mathfrak{p}}
\newcommand\xx{\mathbf{x}}
\newcommand\yy{\mathbf{y}}
\newcommand\GL{\mathit{GL}}
\newcommand\into{\hookrightarrow}
\newcommand\nsub{\trianglelefteq}
\newcommand\onto{\twoheadrightarrow}
\newcommand\minus{\smallsetminus}
\newcommand\goesto{\rightsquigarrow}
\newcommand\nsubneq{\vartriangleleft}

%redefined math symbols taking no arguments
\newcommand\<{\langle}
\renewcommand\>{\rangle}
\renewcommand\iff{\Leftrightarrow}
\renewcommand\phi{\varphi}
\renewcommand\implies{\Rightarrow}

%new math symbols taking arguments
\newcommand\ol[1]{{\overline{#1}}}

%redefined math symbols taking arguments
\renewcommand\mod[1]{\ (\mathrm{mod}\ #1)}

%roman font math operators
\DeclareMathOperator\aut{Aut}

%for easy 2 x 2 matrices
\newcommand\twobytwo[1]{\left[\begin{array}{@{}cc@{}}#1\end{array}\right]}

%for easy column vectors of size 2
\newcommand\tworow[1]{\left[\begin{array}{@{}c@{}}#1\end{array}\right]}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{exercise}[theorem]{Exercise}

\title{Bosonic Codes for Pedestrians}
\author{Faris Sbahi}

\begin{document}
\maketitle

Quantum error correction is necessary to achieve fault tolerant quantum communication. In other words, one must implement a scheme to encode information redundantly into physical degrees of freedom so that information can be preserved in the presence of noise. One such scheme is continuous variable quantum information processing using bosonic modes \cite{braunstein1998error, braunstein2005quantum, niset2008experimentally, aoki2009quantum, lloyd1998analog, lassen2010quantum}. In this case, one encodes information in the space corresponding to the occupation number of a harmonic oscillator. Hence, one can express the code subspace in terms of number states $\{\ket{n}\}^\infty_{n=0}$ \cite{michael2016new}, position and momentum eigenstates $\{\ket{x}\}_{x\in\RR}$ and $\{\ket{p}\}_{p\in\RR}$  \cite{gottesman2001encoding}, or a few coherent states $\{\ket{\alpha}\}_{\alpha\in S}$ (for some finite set $S$) \cite{cochrane1999macroscopically}.

The first studied continuous variable scheme utilizing bosonic modes is known as the two-mode “dual-rail” encoding published in 1995 \cite{chuang1995simple}. Nowadays, there are several bosonic codes being evaluated in the fault tolerant quantum computation race. In this review, we'll consider a few of the most popular contenders: first, we'll develop a practical bosonic error model. Next, we'll study three popular single mode codes with impressive protection capabilities with respect to this model. Then, we'll consider the work of \cite{albert2017performance} to evaluate the performance of these codes. Finally, we'll consider hardware-efficient multi-mode extensions which are notable for their progress toward physical realizability.

\section{Introduction}

\subsection{Definitions}

The generic task of quantum error correction is to find two logical code words---a qubit---embedded in a large Hilbert space. The code words are required to be robust such that if any one of the single, independent errors $E_{l,k} \in \mathcal{E}$ occurs, no quantum information is lost and any quantum superposition of the logical code words can be faithfully recovered. This is equivalent to finding two logical code words $\ket{W_\sigma}$, where $\sigma = \uparrow, \downarrow$, that satisfy the quantum error correction criteria, known also as the Knill-Laflamme conditions \cite{nielsen2002quantum}.

\begin{align}
\label{eq:k-l}
\bra{W_\sigma} E_l^\dag E_k \ket{W_\sigma} = \alpha_{l, k} \delta_{\sigma, \sigma'}	
\end{align}

for all $E_{l,k} \in \mathcal{E}$ such that $\alpha_{l,k}$ are entries of a Hermitian matrix and independent of the logical words. The independence of entries $\alpha_{l,k}$ from the logical code words and the structure of the non-diagonal entries guarantee that the different errors are distinguishable and correctable.

Notationally, we'll refer to a harmonic oscillator's non-Hermitian creation and annihilation operators as $a^\dag$ and $a$, respectively. Furthermore, we define $\hat{n} := \hat{a}^{\dag }\hat{a}$. Recall the relations, with respect to Fock states $\ket{n}$,

\begin{align*}
\hat{a}^{\dagger }|n\rangle &={\sqrt {n+1}}|n+1\rangle, \qquad \hat{a}\ket{n}={\sqrt {n}}|n-1\rangle \\
\hat{n}\ket{n} &= n\ket{n} \\
[\hat{a}, \hat{a}^{\dag }]&=1, \qquad[\hat{n},\hat{a}^{\dag }]=\hat{a}^{\dag }, \qquad[\hat{n}, \hat{a}]=-\hat{a},
\end{align*}

Note the natural convention of calling $\hat{n}$ the "number" operator, based upon its Fock state relation above. Hence, we can develop a notion of parity by considering action by

\begin{align}
\label{eq:parity}
(-1)^{\hat{n}}	
\end{align}


Also, recall the definition of coherent states $\ket{\alpha}$ which refer to eigenstates of the annihilation operator,

$$
|\alpha\rangle =e^{-{|\alpha|^2\over2}}\sum_{n=0}^{\infty}{\alpha^n\over\sqrt{n!}}|n\rangle =e^{-{|\alpha|^2\over2}}e^{\alpha\hat a^\dagger}|0\rangle ~,
$$

We will call errors generated by action of $\hat{a}$ "loss" errors, by $\hat{a}^\dag$ "gain" errors, and by $\hat{n}$ "dephasing" errors. 

\section{Bosonic Error Models}

It's especially important to consider a practical bosonic error model before designing a bosonic code because of the unique nature of photon errors. In particular, photons are prone to loss, and photon-photon interactions are extremely weak. Hence, bosonic QEC codes focus on correcting photon-loss errors using very limited forms of photon-photon interactions while striving to be hardware efficient \cite{niu2018hardware}. 

We can describe this using the pure-loss channel, which is a model for broadband-line and free-space communication and it is the most common incoherent error pro- cess in optical and microwave cavities \cite{albert2017performance}. The second most common error is cavity dephasing, which is caused by fluctuations in the cavity frequency. Optical cavities have to be actively stabilized to fix the frequency, but the effects of such fluctuations are small relative to effects of energy loss, particularly in microwave cavities. 

The bosonic pure-loss channel is given by $N_\gamma = \exp(\kappa t D)$ ($\gamma$ defined below) with superoperator $D(\cdot) = \hat{a} \hat{a}^\dag - 1/2 \{ \hat{n} , \cdot \}$, excitation loss rate $\kappa$,  and time interval $t$ \cite{albert2017performance}. Another way to represent this is in the Kraus representation with Kraus operators

\begin{align}
\label{eq:kraus}
E_l &= \Big(\frac{\gamma}{1-\gamma}\Big)^{l / 2} \frac{\hat{a}^l}{\sqrt{l!}}(1 - \gamma)^{\hat{n} / 2}
\end{align}
where
$$
\gamma = 1 - \exp(- \kappa t)
$$

This is derived by integrating over all the possible photon loss "jump" times of exactly $l$ photon jumps during a small finite time interval $\delta t$ \cite{chuang1997bosonic}, similar in spirit to the Feynmann path integral. Therefore, the channel can be described as 

$$
N_\gamma = \sum_l^\infty E_l \rho E_l^\dag
$$

for density operator $\rho$.

Observe that this channel does not contain the identity as a Kraus operator when $\gamma \neq 0$ due to the "damping" ("back-action") term $(1-\gamma)^{n / 2}$ which results from the non-triviality of observing no photon jump. So, even if there is no loss, there is still redistribution of the probabilities of being in Fock states. Furthermore, both this redistribution and photon loss take place over continuous time and so continuous time evolutions results in an infinite set of possible errors. Therefore, the error correction criteria (\ref{eq:k-l}) can't be utilized directly. 

Instead, one can expand each error operator in powers of $\kappa \delta t$ (where again $\delta t$ is a small finite time interval) and choose to correct up to a given highest order. This is termed "approximate quantum error correction" \cite{mandayam2012towards}. It is then enough to satisfy the quantum error correction criteria (\ref{eq:k-l}) only approximately such that the original state can be recovered with an accuracy given by the same highest order in $\kappa \delta t$ \cite{michael2016new}.

So, if we perform a Taylor series expansion of each of the Kraus operators $E_l$ above and consider correcting both the photon loss and back-action contributions up to order $O[(\kappa \delta t)^L]$ for some specified $L$, then we can derive a new set of approximate error correction conditions. The full derivation is contained in \cite{michael2016new} but we summarize the results below which we'll utilize in our analysis in the next sections.

First, observe that Kraus operators $E_{l>L}$ can be ignored since they have the effect of order at least $L+1$. So, denote $E_{\mu, l}$ as the $\mu$th entry of the expansion of (\ref{eq:kraus}) in powers of $(\kappa\delta t)^{1/2}$. Now, for convenience sake, expand each Kraus operator $E_{l \leq L}$ into two contributions

\begin{align*}
E_l &= B_l + C_l + O[(\kappa \delta t)^{L + 1/2}]	\\
\intertext{where}
B_l &= \sum_{\mu = l }^L E_{\mu, l}(\kappa \delta t)^{\mu / 2} \\
C_l &= \sum_{\mu = L+1 }^{2L - 1} E_{\mu, l}(\kappa \delta t)^{\mu / 2} \\
\end{align*}

Then, we can rewrite our channel as 

\begin{align*}
N_\gamma &= \sum_{l=0}^\infty E_l \rho E_l^\dag\\
&= \sum_{l=0}^L E_l \rho E_l^\dag + O[(\kappa \delta t)^{L + 1}] \\
&= \sum_{l=0}^L(B_l \rho B_l^\dag + B_l \rho C_l^\dag + C_l \rho B_l^\dag) + O[(\kappa \delta t)^{L + 1}]
\end{align*}

Hence, one can ignore the negligible $O[(\kappa \delta t)^{L + 1}]$ part of the interference terms and verify only that the effect of the remaining important part is independent of the logical code words. Together, if the error operators $B_l$ and $C_l$ for all $0 \leq l \leq L$ satisfy the two following conditions,

\begin{align}
\label{eq:aqec}
\begin{split}
\bra{W_\sigma} B_l^\dag B_l \ket{W_{\sigma'}} &= \beta_l \delta_{\sigma \sigma'} \\
\bra{W_\sigma} B_l^\dag C_l \ket{W_{ \sigma'}} &= \nu_l \delta_{\sigma \sigma'}	+ O[(\kappa \delta t)^{L + 1}]
\end{split}
\end{align}

then the original state can be corrected up to order $O[(\kappa \delta t)^L]$.

These equations have the interpretation of allowing us to determine to what order a code corrects both loss errors and back-action errors. In this case of binomial codes, we'll see that we can correct back-action to the same order as photon loss. Other codes have addressed the back-action contribution by constructing multimode codes \cite{chuang1997bosonic}. These codes avoid no-jump evolution by combining two or more physical elements with identical decay rates and constructing the logical code words such that they are superpositions of states with the same combined total excitation number.

\section{Single Mode Codes}

First, we emphasize why we must establish new codes for bosonic systems in the first place. What if we used a simple encoding of $M$ qubits: $2^M$ Fock states cover photon numbers $0, 1, . . . , (2^{M - 1})$. Use binary representation: $\ket{n} = \ket{b_{M-1} b_{M-2} \cdots b_0 }$. The $j$th binary digit represents the eigenvalue $(1 + Z_j)/2$ for the corresponding physical qubit. E.g., $n=8$: $\ket{1000}$. Photon loss occurs, $a : \ket{1000} \mapsto \ket{0111}$. Hence, as the authors of \cite{michael2016new} note, QEC schemes based on models of independent single qubit errors cannot be easily transferred to this problem. Luckily, the stabilizer formalism provides useful intuition for codes we'll discuss

\subsection{A Simple Example}
\label{sec:simple}

So, consider a simple bosonic code to protect against $\mathcal{E} = \{ I, \hat{a} \}$. Define $\ket{W_\uparrow} = \frac{\ket{0} + \ket{4}}{2}$, $\ket{W_\downarrow} = \ket{2}$. Hence, $\ket{E_1} = \ket{3}$ and $\ket{E_2} = \ket{1}$. We can distinguish states by measuring number and checking mod 4. Observe that both logical states have the same mean photon number i.e. $\bra{W_\sigma} \hat{n} \ket{W_\sigma} = 2, \forall \sigma$. Therefore, $\hat{a} : \alpha\ket{W_\uparrow} + \beta\ket{W_\downarrow} \mapsto \alpha \ket{E_1} + \beta \ket{E_2}$. We say that this condition implies that there is no "deformation".

How can we generalize from here? Well, we can add greater spacing between states so that we can detect higher order loss errors or alternatively gain errors. Furthermore, observe that action by $n$ "dephases" in the sense that, after transformation, the relative phases of the Fock states are transformed. This action leads to a superposition of codewords and error words. Project onto word basis to recover (efficient).

\subsection{Cat Codes}

Cat codes were first discovered in \cite{cochrane1999macroscopically} in the case of a single mode. Several papers have extended these codes to the multi-mode case in order to correct more errors or offer a hardware-efficient implementation \cite{albert2018multimode, leghtas2013hardware, mirrahimi2014dynamically} and we will summarize these results in Section \ref{sec:multi-cat}.

Now, consider using a superposition of "well-separated" coherent states as the logical state encoding. Usually, cat codes are presented in the case of correcting a single loss error $\hat{a}$, but it can be generalized to the multiple-loss case \cite{albert2018multimode}. Hence, we'll present the single-loss case.

It is aesthetically pleasing to develop the code in terms of symmetries over a stabilizing operator $J \sim \hat{a}^4$. In other words, our logical code space, where each element is a superposition of coherent states, is preserved under action by $J$ (up to a phase), similarly to the familiar stabilizer formalism.

We observe that parity, as defined in (\ref{eq:parity}), commutes with $J$. Hence, we can use parity to label basis states of our code subspace by defining parity operator

\begin{align*}
P_{\Pi} = \frac{1+(-1)^{\hat{n}}}{2}	
\end{align*}

where $\Pi \in \{0, 1\}$.

We claimed that logical cat states are well-separated and elaborate this notion to mean, in particular, that the basis elements of cat states are projections of the parity operator on coherent states. Hence,

\begin{align*}
\ket{\alpha_\Pi} &= N_\Pi P_\Pi \ket{\alpha}
\end{align*}

where $N_\Pi$ is the normalization factor. Hence, we observe that

\begin{align*}
\ket{\alpha_\Pi} \sim \begin{cases} \ket{\Pi},  &\alpha \rightarrow 0\\ \ket{\alpha} + (-1)^\Pi \ket{-\alpha}, &\alpha \rightarrow \infty \end{cases}
\end{align*}

So, observe the following relations

\begin{align}
\label{eq:cat-rels}
\begin{split}
\hat{a} \ket{\alpha_0} &= \ket{\alpha} - \ket{-\alpha} = \ket{\alpha_1} \\
\hat{a} \ket{\alpha_1} &= \ket{\alpha} + \ket{-\alpha} = \ket{\alpha_0} \\
\hat{a} \ket{i\alpha_0} &= i(\ket{i\alpha} - \ket{-i\alpha})\\
\hat{a} \ket{i\alpha_1} &= i(\ket{i\alpha}  + \ket{-i\alpha})
\end{split}
\end{align}

which we will utilize shortly. So, we can define logical code states $C_\mu, \mu \in \{ \uparrow, \downarrow \}$ as 

\begin{align*}
\ket{C_\mu^{\alpha, \Pi}} &= N_{\mu, \Pi} (\ket{\alpha_\Pi} + (-1)^\mu \ket{i \alpha_\Pi})\\
&= N_{\mu, \Pi} \sum_{p\text{ even/odd}}^{[0, \infty)}\sqrt{\exp(-|\alpha|^2)\frac{
\alpha^{4p}}{2p!}}\ket{2p}
\end{align*}

where $N_{\mu, \Pi}$ are the normalization factors which evidently become equal as $\alpha \rightarrow \infty$. 


We can show that there is a $\mu$-dependence in the normalization factor which is suppressed exponentially in $\alpha^2$ \cite{albert2018multimode}. Similarly, it turns out that that when considering $p$th order dephasing errors $\hat{n}^p$, the term

$$
\bra{C^{\alpha, \Pi}_{\uparrow}} n^p \ket{C^{\alpha, \Pi}_{\uparrow}} - \bra{C^{\alpha, \Pi}_{\downarrow}} n^p \ket{C^{\alpha, \Pi}_{\downarrow}}
$$ 

is nonzero by virtue of the $\mu$-dependence of the normalization factors. Hence, similarly, this difference goes to zero as $\alpha \rightarrow \infty$. So, according to (\ref{eq:k-l}), cat states are potentially immune from any order of dephasing.

\subsubsection{Discrete Loss Errors}

Now, we use the relations above (\ref{eq:cat-rels}) to specify action of $\hat{a}$ on our cat code states.

\begin{align*}
\hat{a}	\ket{C^{\alpha, 0}_{\uparrow}} &= \hat{a}	\ket{C^{\alpha, 1}_{\downarrow}}, \qquad
\hat{a}	\ket{C^{\alpha, 0}_{\downarrow}} = \hat{a}	\ket{C^{\alpha, 1}_{\uparrow}}\\
\hat{a}	\ket{C^{\alpha, 1}_{\uparrow}} &= \hat{a}	\ket{C^{\alpha, 0}_{\uparrow}},\qquad 
\hat{a}	\ket{C^{\alpha, 1}_{\uparrow}} = \hat{a}	\ket{C^{\alpha, 0}_{\uparrow}}
\end{align*}

Hence, we see that application of $\hat{a}$ on an even parity ($\Pi = 0$) cat state transforms to the odd parity subspace ($\Pi = 1$) while also creating a logical bit flip ($\uparrow \leftrightarrow \downarrow$). On the other hand, $\hat{a}$ transforms an odd parity state to an even parity state without the logical bit flip. Therefore, to the order that the approximate quantum error conditions (\ref{eq:aqec}) are satisfied, the quantum information is preserved and, as long as photon jumps are detected and recorded, there is no further correction needed. In other words, the limiting factor of the accuracy of cat codes is independent of action of detected single-loss $\hat{a}$.

However, if $\hat{a}^2$ is applied, then we evidently generate a logical bit flip while preserving parity. Therefore, our parity measurement will indicate no change in parity despite a non-trivial transformation taking place. Hence, $\hat{a}^2$ is non-correctable.

\subsubsection{Dephasing Errors}

As noted above, dephasing errors are suppressed to the same order that the normalization constants for the $p$th moment of photon number are equivalent for each of the logical states. In particular, dephasing errors are suppressed exponentially in $\alpha^2$.

\subsubsection{Continuous Errors}

Now, we can use the approximate quantum error correction conditions we developed in the previous section. Observe that from equation (\ref{eq:kraus}), $E_1 = \Big(\frac{\gamma}{1-\gamma}\Big)^{1 / 2} \hat{a} (1 - \gamma)^{\hat{n} / 2} = \hat{a} \gamma^{1/2} (1- \gamma)^{\hat{n}}$. Hence, for all $\Pi$,

\begin{align*}
&\bra{C^{\alpha, \Pi}_{\uparrow}}E_1E_1^\dag\ket{C^{\alpha, \Pi}_{\uparrow}} - \bra{C^{\alpha, \Pi}_{\downarrow}}	E_1E_1^\dag\ket{C^{\alpha, \Pi}_{\downarrow}}	\\
&\approx \kappa\delta t (\bra{C^{\alpha, \Pi}_{\uparrow}}\hat{n}\ket{C^{\alpha, \Pi}_{\uparrow}} - \bra{C^{\alpha, \Pi}_{\downarrow}}	\hat{n}\ket{C^{\alpha, \Pi}_{\downarrow}}\\
&\approx 4 \kappa \delta t |\alpha|^2  \exp(-|\alpha|^2)(\sin |\alpha|^2 + \cos|\alpha|^2)
\end{align*}

and so the approximation quantum error correction conditions (\ref{eq:aqec}) are violated when this is nonzero, since there exists uncorrectable errors of order $O(\kappa \delta t)$ and we are consider single-loss errors. Observe that the term goes to zero as $\alpha\rightarrow \infty$, however. Hence, to suppress these errors, we may require a large $\alpha$. Recalling that the $\alpha$ label for a coherent state $\ket{\alpha}$ indicates the mean photon number for the Poissonian distribution of number states, we see that this potential increase in average photon number relative to other codes can then introduces a greater error rate.

\subsection{Binomial Codes}

Now, we consider a new class of codes known as "binomial codes" which were developed in  \cite{michael2016new}. Binomial codes are similar in spirit to the code we described in Section \ref{sec:simple}, since we use Fock states as our physical degrees of freedom to encode logical states.


So, consider if we desire to protect against $\mathcal{E} = \{I, a, a^2, \cdots, a^L, a^\dag, \cdots, (a^\dag)^G, N, \cdots, N^D \}$. The authors then suggest a simple class of codes of the following form

$$
\ket{W_{\uparrow / \downarrow}} = \frac{1}{\sqrt{2^N}} \sum_{ p\text{ even/odd}}^{[0, N+1]} \sqrt{\binom{N+1}{ p }} \ket{p(S+1)}
$$

with spacing $S = L+G$ and maximum order $N = \max\{L, G, 2D\}$. Hence, we can see that the spacing between Fock states is given by $S+1$ and so we can distinguish errors by measuring photon number modulo $S+1$. Again, this works as a result of the spacing since a state can be shifted downward by repeated application of $\hat{a}$ up to $S$ times until becoming equivalent to the next Fock state originally below.

\subsubsection{Discrete Loss/Gain Errors}

 Furthermore, they consider loss errors in the context of the discrete error correction conditions (\ref{eq:k-l}) and show that

$$
\bra{W_\uparrow}(\hat{a}^\dag)^l\hat{a}^l \ket{W_{\uparrow}} = \bra{W_\downarrow}(\hat{a}^\dag)^l\hat{a}^l \ket{W_{\downarrow}}
$$ 

for $l \leq \max\{L, G\}$. They show this by observing that $(\hat{a}^\dag)^l\hat{a}^l = \hat{n}^l$. Then, they write the difference in the $l$th moment of photon number of codewords as the $l$th derivative of $(1+x)^{N+1}\vert_{x=-1}$ with $l \leq \max\{L, G\}$ (up to a factor) by using the binomial formula. Furthermore, since we're using orthonormal Fock states as our basis it's clear that

$$
\bra{W_\sigma}(\hat{a}^\dag)^l\hat{a}^m \ket{W_{\sigma'}} = 0
$$  

for $l, m \leq \max\{L, G\}, l \neq m$. So, the discrete error correction conditions are obeyed.

Hence, since we show that the $l$th moment of $\ket{n}$ is equivalent for both logical code words, it also follows that the mean photon number is equivalent for both code words given that the mean is the first moment. So, there is no deformation by measuring the mean photon number.

Observe that from above the "quantum error correction matrix" as defined by the matrix elements $Q_{(l, k)} = \alpha_{l, k}$ from (\ref{eq:k-l}) is diagonal when only considering loss/gain errors.

\subsubsection{Discrete Dephasing Errors}

Now, if we consider dephasing errors as well, the error correction matrix is no longer necessarily diagonal but is still Hermitian (as required). For that reason, to detect and recover those errors one needs to make projective measurements in an orthonormalized basis, as with the code in Section \ref{sec:simple}. After a detection of an error, the original state is recovered by a unitary operation performing a state transfer between the subspaces of the error and logical code words.

\subsubsection{Continuous Errors}

\subsection{GKP Codes}

\begin{itemize}
\item Use the continuous basis of non-normalizable eigenstates of the position operator $x$	
\item Not enough time!
\item Quantum analoge of frequency combs
\item Key: protect against displacement errors $D_\alpha = \exp{\alpha a^\dag  - \alpha* a}$, not loss errors explicitly
\end{itemize}

\section{Discussion}

\subsection{Theoretical Comparisons}

The single-mode binomial codes require an explicit correction gate at every timestep whether or not a photon jump has occurred. However, binomial codes satisfy the approximate quantum error correction conditions to order $\delta t$ with a smaller average photon number: $\bar{n} = 2$ for the code of Eq. (2), rather than $\bar{n} = 2.3$ for the cat code that minimizes Eq. (32). Furthermore, the binomial codes operate in a restricted Hilbert space, which could be beneficial for the practical construction of the unitary operators required for error diagnosis and recovery. This particularly applies to errors involving $\hat{a}^\dag$ operators, whose operation on cat codes is less straightforward than $\hat{a}$ operators alone.

The Fock state distributions of the binomial and cat codes are binomial and Poissonian, respectively. As the average number of photons is increased (larger N), both of these distributions approach a normal distribution, and so the binomial and cat codes asymptotically approach each other. 

Furthermore, since no-jump evolution damps coherent states, $(1 - \gamma)^{\hat{n}}\ket{\alpha} = \ket{(1 - \gamma) \alpha}(1 - \gamma)^{\hat{n}}\ket{\alpha} = \ket{(1 - \gamma) \alpha}$, the only necessary correction is a “re-pumping” of the cat states. This can be achieved using a discrete unitary correction operation (analogous to the binomial codes) or continuous non-linear amplification coming from an engineered reservoir [17, 18] (analogous to similar passive/autonomous error correction schemes [94, 95]). The basic principle of passive schemes is stabilization of a manifold of codewords as an attractive (stable) fixed-point of drives and dissipation so that the only remaining task is to track generalized parity for photon jumps [18]. The cat codes based on equal amplitude coherent state superpositions, cf. Eq. (31), are ‘natural’ candidates for these purposes since they require only gradual continuous inversion of the damping of the coherent state amplitude without active discrete correction stages. The two-leg cat has already been stabilized by reservoir engineering to achieve dominant two-photon drive and two-photon dissipation [96].

\begin{figure}[H]
\centering
\includegraphics[width=0.5\linewidth,keepaspectratio]{binom_cat.png}	
\caption{Figure borrowed from \cite{michael2016new} comparing binomial codes to cat codes. Observe that, in principle, unlimited dephasing errors can be tolerated by cat codes.}
\end{figure}

\subsection{Performance Comparisons}

VV Albert considers "channel fidelity", $F_\mathcal{E}$, which is the overlap between the initial state and the final state when considering an initial Bell state such that only the first qubit is acted on by the channel

Optimal recovery for each code is computable via a semi-definite program

\begin{figure}[H]
\centering
\includegraphics[width=0.5\linewidth,keepaspectratio]{fidelity.png}	
\end{figure}

\subsection{Multi-Mode Extensions}

\subsubsection{Cat Codes}\label{sec:multi-cat}

\begin{itemize}
		\item Pair-cat codes (VV Albert)
		\item Reduction in order of nonlinearity required for physical realization (as with $\chi(2)$)
		\item With ordinary cat codes and current technology, the number parity syndrome makes it difficult to realize simultaneous discrete (usually for loss) and continuous error correction  (usually for dephasing)
	\end{itemize}

\begin{figure}
\centering
\includegraphics[width=\linewidth,keepaspectratio]{pair_cat.png}	
\caption{Figure from \cite{albert2018multimode} comparing single-mode cat codes to pair-cat codes}
\end{figure}


\subsubsection{Binomial Codes}

Hardware Efficient Constructions

Noon codes

\begin{itemize}
	\item To create more useful quantum superpositions of Fock states which can store quantum information, it is necessary to couple the bosonic mode to a non-linear element, e.g., a superconducting qubit, a trapped ion, or a Rydberg atom
		\item $\chi(2)$ code uses $O(n)$ instead of $O(n^2)$ qubits that previous two mode codes had used to correct $m$ loss/gain/dephasing errors (Niu)
		\item Inspired by cat code, but uses lower order non-linearity
	\end{itemize}

\subsection{Broader Context}

\subsubsection{Continuous Variable Systems}

\subsubsection{Future Developments}

\nocite{*}
\bibliography{qec_final_project.bib}
\bibliographystyle{amsplain}

\end{document}